#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd -- "${SCRIPT_DIR}/../.." && pwd)"

# shellcheck source=lib.sh
source "${SCRIPT_DIR}/lib.sh"

usage() {
  cat <<EOF
Usage: flows/scripts/pyc <command>

Commands:
  build        Configure+build pycc/pyc-opt into ./build
  smoke        Run compiler smoke (emit+pycc) and a small simulation smoke set

Env:
  LLVM_DIR, MLIR_DIR   Optional. If unset, flows/scripts/pyc tries to infer via llvm-config.
  PYCC          Path to pycc (overrides auto-detect).
EOF
}

find_llvm_config() {
  if command -v llvm-config >/dev/null 2>&1; then
    command -v llvm-config
    return 0
  fi
  for v in 19 18 17 16 15; do
    if command -v "llvm-config-${v}" >/dev/null 2>&1; then
      command -v "llvm-config-${v}"
      return 0
    fi
  done
  return 1
}

cmd="${1:-help}"
shift || true

case "${cmd}" in
  -h|--help|help)
    usage
    ;;

  build)
    if [[ -z "${LLVM_DIR:-}" || -z "${MLIR_DIR:-}" ]]; then
      if LLVM_CONFIG="$(find_llvm_config)"; then
        pyc_log "inferring LLVM_DIR/MLIR_DIR via ${LLVM_CONFIG}"
        LLVM_DIR="$("${LLVM_CONFIG}" --cmakedir)"
        MLIR_DIR="$(dirname "${LLVM_DIR}")/mlir"
        export LLVM_DIR MLIR_DIR
      else
        pyc_die "set LLVM_DIR and MLIR_DIR (or install llvm-config) before building"
      fi
    fi

    pyc_log "configure (build/)"

    # IMPORTANT: Avoid mixing compilers when linking against the pinned LLVM/MLIR build.
    # On Windows/MSYS2, the LinxISA-pinned LLVM/MLIR is commonly built with MinGW GCC.
    # If pyCircuit is built with Clang while linking GCC-built static libs, we can hit
    # COFF/COMDAT ODR issues (multiple definitions of inline guard vars, etc.).
    # Force GCC/G++ here for MSYS2 MinGW environments.
    extra_cmake_args=()
    uname_s="$(uname -s 2>/dev/null || true)"
    if [[ "${MSYSTEM:-}" == MINGW64* || "${uname_s}" == MINGW* || "${uname_s}" == MSYS* ]]; then
      extra_cmake_args+=(
        -DCMAKE_C_COMPILER=gcc
        -DCMAKE_CXX_COMPILER=g++
      )
    fi

    cmake -G Ninja -S "${ROOT_DIR}" -B "${ROOT_DIR}/build" \
      -DCMAKE_BUILD_TYPE=Release \
      -DLLVM_DIR="${LLVM_DIR}" \
      -DMLIR_DIR="${MLIR_DIR}" \
      "${extra_cmake_args[@]}"

    pyc_log "build pycc (pyc-opt is optional, run ninja pyc-opt to try)"
    ninja -C "${ROOT_DIR}/build" pycc
    ninja -C "${ROOT_DIR}/build" pyc-opt 2>/dev/null || true
    pyc_log "ok: ${ROOT_DIR}/build/bin/pycc"
    ;;

  smoke)
    pyc_find_pycc
    pyc_log "run example compile smoke"
    PYCC="${PYCC}" bash "${ROOT_DIR}/flows/scripts/run_examples.sh"
    pyc_log "run simulation smoke"
    PYCC="${PYCC}" bash "${ROOT_DIR}/flows/scripts/run_sims.sh"
    pyc_log "ok: smoke passed"
    ;;

  *)
    pyc_die "unknown command: ${cmd} (run: flows/scripts/pyc help)"
    ;;
esac
