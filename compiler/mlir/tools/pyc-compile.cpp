#include "pyc/Dialect/PYC/PYCDialect.h"
#include "pyc/Dialect/PYC/PYCOps.h"
#include "pyc/Emit/CppEmitter.h"
#include "pyc/Emit/VerilogEmitter.h"
#include "pyc/Transforms/Passes.h"

#include "mlir/Dialect/Arith/IR/Arith.h"
#include "mlir/Dialect/Func/IR/FuncOps.h"
#include "mlir/Dialect/Func/Extensions/InlinerExtension.h"
#include "mlir/Dialect/SCF/IR/SCF.h"
#include "mlir/IR/BuiltinOps.h"
#include "mlir/IR/DialectRegistry.h"
#include "mlir/Parser/Parser.h"
#include "mlir/Pass/PassManager.h"
#include "mlir/Transforms/Passes.h"
#include "llvm/ADT/SmallSet.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/ADT/StringMap.h"
#include "llvm/ADT/Hashing.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/JSON.h"
#include "llvm/Support/FileSystem.h"
#include "llvm/Support/InitLLVM.h"
#include "llvm/Support/MemoryBuffer.h"
#include "llvm/Support/Path.h"
#include "llvm/Support/SourceMgr.h"
#include "llvm/Support/raw_ostream.h"

#include <algorithm>
#include <cctype>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <limits>
#include <optional>
#include <string>
#include <utility>
#include <vector>

using namespace mlir;

static llvm::cl::opt<std::string> inputFilename(llvm::cl::Positional, llvm::cl::desc("<input .pyc>"),
                                                llvm::cl::init("-"));

static llvm::cl::opt<std::string> outputFilename("o", llvm::cl::desc("Output file"), llvm::cl::init("-"));

static llvm::cl::opt<std::string> emitKind("emit", llvm::cl::desc("Emission target: verilog|cpp"),
                                           llvm::cl::init("verilog"));

static llvm::cl::opt<std::string> cppSplitMode(
    "cpp-split",
    llvm::cl::desc("C++ out-dir split mode: module|none"),
    llvm::cl::init("module"));

static llvm::cl::opt<unsigned> cppShardThresholdLines(
    "cpp-shard-threshold-lines",
    llvm::cl::desc("Shard oversized C++ module sources when generated line count exceeds this threshold"),
    llvm::cl::init(120000));

static llvm::cl::opt<unsigned> cppShardThresholdBytes(
    "cpp-shard-threshold-bytes",
    llvm::cl::desc("Shard oversized C++ module sources when generated byte count exceeds this threshold"),
    llvm::cl::init(4 * 1024 * 1024));

static llvm::cl::opt<std::string> cppManifestPath(
    "cpp-manifest",
    llvm::cl::desc("C++ compile manifest path (default: <out-dir>/cpp_compile_manifest.json)"),
    llvm::cl::init(""));

static llvm::cl::opt<std::string> targetKind("target", llvm::cl::desc("Target: default|fpga"),
                                             llvm::cl::init("default"));

static llvm::cl::opt<bool> includePrims("include-primitives",
                                        llvm::cl::desc("Emit `include` for PYC Verilog primitives"),
                                        llvm::cl::init(true));

static llvm::cl::opt<std::string>
    outDir("out-dir", llvm::cl::desc("Output directory (split per module; emits manifest.json)"), llvm::cl::init(""));

static llvm::cl::opt<unsigned> logicDepthLimit(
    "logic-depth",
    llvm::cl::desc("Maximum combinational logic depth allowed between sequential boundaries"),
    llvm::cl::init(32));

static llvm::cl::opt<std::string> simMode("sim-mode", llvm::cl::desc("Simulation mode: default|cpp-only"),
                                          llvm::cl::init("default"));

static llvm::cl::opt<bool> cppOnlyPreserveOps(
    "cpp-only-preserve-ops",
    llvm::cl::desc("Preserve operation-granular C++ scheduling in --sim-mode=cpp-only (disables comb fusion)"),
    llvm::cl::init(false));

static std::string topSymbol(ModuleOp module) {
  if (auto topAttr = module->getAttrOfType<FlatSymbolRefAttr>("pyc.top"))
    return topAttr.getValue().str();
  if (auto first = module.getOps<func::FuncOp>().begin(); first != module.getOps<func::FuncOp>().end())
    return (*first).getSymName().str();
  return "";
}

static LogicalResult writeFile(llvm::StringRef path, llvm::StringRef contents) {
  std::error_code ec;
  llvm::raw_fd_ostream os(path, ec, llvm::sys::fs::OF_Text);
  if (ec) {
    llvm::errs() << "error: cannot open " << path << ": " << ec.message() << "\n";
    return failure();
  }
  os << contents;
  return success();
}

static std::optional<std::string> findPrimitivesDir(const char *argv0) {
  // Allow explicit override (useful for installed toolchains).
  if (const char *env = std::getenv("PYC_PRIMITIVES_DIR")) {
    llvm::SmallString<256> cand(env);
    llvm::sys::path::append(cand, "pyc_reg.v");
    if (llvm::sys::fs::exists(cand))
      return std::string(env);
  }

  auto tryDir = [&](llvm::SmallString<256> dir) -> std::optional<std::string> {
    llvm::SmallString<256> probe(dir);
    llvm::sys::path::append(probe, "pyc_reg.v");
    if (llvm::sys::fs::exists(probe))
      return dir.str().str();
    return std::nullopt;
  };

  auto tryRoot = [&](llvm::StringRef root) -> std::optional<std::string> {
    llvm::SmallString<256> dir(root);
    llvm::sys::path::append(dir, "runtime", "verilog");
    if (auto d = tryDir(dir))
      return d;

    dir = root;
    llvm::sys::path::append(dir, "include", "verilog");
    if (auto d = tryDir(dir))
      return d;

    dir = root;
    llvm::sys::path::append(dir, "include", "pyc", "verilog");
    if (auto d = tryDir(dir))
      return d;
    return std::nullopt;
  };

  // Current working directory.
  llvm::SmallString<256> cwd;
  if (!llvm::sys::fs::current_path(cwd)) {
    if (auto d = tryRoot(cwd))
      return d;
  }

  // Walk up from the executable path (common for in-tree builds).
  llvm::SmallString<256> exe(argv0 ? argv0 : "");
  if (!exe.empty()) {
    llvm::SmallString<256> rp;
    if (!llvm::sys::fs::real_path(exe, rp)) {
      llvm::SmallString<256> cur = llvm::sys::path::parent_path(rp);
      for (unsigned i = 0; i < 6 && !cur.empty(); ++i) {
        if (auto d = tryRoot(cur))
          return d;
        cur = llvm::sys::path::parent_path(cur);
      }
    }
  }

  return std::nullopt;
}

static LogicalResult emitPrimitivesFile(llvm::StringRef outPath, llvm::StringRef primDir, bool targetFpga) {
  static const char *kFiles[] = {
      "pyc_reg.v",
      "pyc_fifo.v",
      "pyc_byte_mem.v",
      "pyc_sync_mem.v",
      "pyc_sync_mem_dp.v",
      "pyc_async_fifo.v",
      "pyc_cdc_sync.v",
  };

  std::string buf;
  llvm::raw_string_ostream ss(buf);
  ss << "// pyCircuit Verilog primitives (concatenated)\n\n";
  if (targetFpga)
    ss << "`define PYC_TARGET_FPGA 1\n\n";
  for (const char *name : kFiles) {
    llvm::SmallString<256> path(primDir);
    llvm::sys::path::append(path, name);
    auto fileOrErr = llvm::MemoryBuffer::getFile(path);
    if (!fileOrErr) {
      llvm::errs() << "error: cannot read primitive file: " << path << "\n";
      return failure();
    }
    ss << "// --- " << name << "\n";
    ss << fileOrErr->get()->getBuffer() << "\n\n";
  }
  ss.flush();
  return writeFile(outPath, buf);
}

static LogicalResult updateManifest(llvm::StringRef outDirPath, llvm::StringRef top,
                                   std::optional<llvm::json::Array> verilogMods,
                                   std::optional<llvm::json::Array> cppMods) {
  llvm::SmallString<256> path(outDirPath);
  llvm::sys::path::append(path, "manifest.json");

  llvm::json::Object manifest;
  if (llvm::sys::fs::exists(path)) {
    if (auto mb = llvm::MemoryBuffer::getFile(path)) {
      if (auto parsed = llvm::json::parse(mb->get()->getBuffer())) {
        if (auto *obj = parsed->getAsObject())
          manifest = *obj;
      }
    }
  }

  manifest["top"] = top.str();
  if (!manifest.get("verilog_modules"))
    manifest["verilog_modules"] = llvm::json::Array();
  if (!manifest.get("cpp_modules"))
    manifest["cpp_modules"] = llvm::json::Array();
  if (verilogMods)
    manifest["verilog_modules"] = std::move(*verilogMods);
  if (cppMods)
    manifest["cpp_modules"] = std::move(*cppMods);

  std::string buf;
  llvm::raw_string_ostream ss(buf);
  llvm::json::OStream j(ss, 2);
  llvm::json::Value v(std::move(manifest));
  j.value(v);
  ss << "\n";
  ss.flush();
  return writeFile(path, buf);
}

struct CppManifestSource {
  std::string path;
  std::string module;
  std::string shard;
  std::string kind;
};

struct SplitMethodDef {
  std::string name;
  std::string declaration;
  std::string definition;
  std::string kind;
  size_t bytes = 0;
  size_t lines = 0;
};

struct SplitModuleResult {
  std::string headerBody;
  std::vector<SplitMethodDef> methods;
};

static std::string trimCopy(llvm::StringRef s) {
  size_t b = 0;
  size_t e = s.size();
  while (b < e && std::isspace(static_cast<unsigned char>(s[b])))
    ++b;
  while (e > b && std::isspace(static_cast<unsigned char>(s[e - 1])))
    --e;
  return s.substr(b, e - b).str();
}

static std::string normalizeWhitespace(llvm::StringRef s) {
  std::string out;
  out.reserve(s.size());
  bool prevSpace = false;
  for (char c : s) {
    if (std::isspace(static_cast<unsigned char>(c))) {
      if (!prevSpace) {
        out.push_back(' ');
        prevSpace = true;
      }
    } else {
      out.push_back(c);
      prevSpace = false;
    }
  }
  return trimCopy(out);
}

static size_t countLines(llvm::StringRef s) {
  if (s.empty())
    return 0;
  size_t n = 1;
  for (char c : s)
    if (c == '\n')
      ++n;
  return n;
}

static size_t findMatchingParen(llvm::StringRef s, size_t openPos) {
  if (openPos >= s.size() || s[openPos] != '(')
    return std::string::npos;
  int depth = 0;
  for (size_t i = openPos; i < s.size(); ++i) {
    char c = s[i];
    if (c == '(')
      ++depth;
    else if (c == ')') {
      --depth;
      if (depth == 0)
        return i;
    }
  }
  return std::string::npos;
}

static size_t findMatchingBraceSimple(llvm::StringRef s, size_t openPos) {
  if (openPos >= s.size() || s[openPos] != '{')
    return std::string::npos;
  int depth = 0;
  bool inLineComment = false;
  bool inBlockComment = false;
  bool inString = false;
  bool inChar = false;
  bool escape = false;
  for (size_t i = openPos; i < s.size(); ++i) {
    char c = s[i];
    char n = (i + 1 < s.size()) ? s[i + 1] : '\0';

    if (inLineComment) {
      if (c == '\n')
        inLineComment = false;
      continue;
    }
    if (inBlockComment) {
      if (c == '*' && n == '/') {
        inBlockComment = false;
        ++i;
      }
      continue;
    }
    if (inString) {
      if (escape) {
        escape = false;
      } else if (c == '\\') {
        escape = true;
      } else if (c == '"') {
        inString = false;
      }
      continue;
    }
    if (inChar) {
      if (escape) {
        escape = false;
      } else if (c == '\\') {
        escape = true;
      } else if (c == '\'') {
        inChar = false;
      }
      continue;
    }

    if (c == '/' && n == '/') {
      inLineComment = true;
      ++i;
      continue;
    }
    if (c == '/' && n == '*') {
      inBlockComment = true;
      ++i;
      continue;
    }
    if (c == '"') {
      inString = true;
      escape = false;
      continue;
    }
    if (c == '\'') {
      inChar = true;
      escape = false;
      continue;
    }
    if (c == '{')
      ++depth;
    else if (c == '}') {
      --depth;
      if (depth == 0)
        return i;
    }
  }
  return std::string::npos;
}

static bool startsWithWord(llvm::StringRef s, llvm::StringRef w) {
  if (!s.starts_with(w))
    return false;
  if (s.size() == w.size())
    return true;
  return std::isspace(static_cast<unsigned char>(s[w.size()])) != 0;
}

static std::string dropCtorInitializerForDecl(llvm::StringRef sig) {
  size_t p = sig.find('(');
  if (p == std::string::npos)
    return sig.str();
  size_t close = findMatchingParen(sig, p);
  if (close == std::string::npos)
    return sig.str();
  size_t colon = std::string::npos;
  for (size_t i = close + 1; i < sig.size(); ++i) {
    if (sig[i] == ':' && !(i > 0 && sig[i - 1] == ':') && !(i + 1 < sig.size() && sig[i + 1] == ':')) {
      colon = i;
      break;
    }
  }
  if (colon == std::string::npos)
    return sig.str();
  return trimCopy(sig.substr(0, colon));
}

static std::string removeDefaultArgs(llvm::StringRef sig) {
  size_t open = sig.find('(');
  if (open == std::string::npos)
    return sig.str();
  size_t close = findMatchingParen(sig, open);
  if (close == std::string::npos)
    return sig.str();

  std::string out;
  out.reserve(sig.size());
  out.append(sig.substr(0, open + 1).str());
  bool skipping = false;
  int depthParen = 0;
  int depthAngle = 0;
  int depthBrace = 0;
  int depthBracket = 0;
  for (size_t i = open + 1; i < close; ++i) {
    char c = sig[i];
    if (!skipping) {
      if (c == '(')
        ++depthParen;
      else if (c == ')')
        --depthParen;
      else if (c == '<')
        ++depthAngle;
      else if (c == '>')
        --depthAngle;
      else if (c == '{')
        ++depthBrace;
      else if (c == '}')
        --depthBrace;
      else if (c == '[')
        ++depthBracket;
      else if (c == ']')
        --depthBracket;

      if (c == '=' && depthParen == 0 && depthAngle == 0 && depthBrace == 0 && depthBracket == 0) {
        skipping = true;
        continue;
      }
      out.push_back(c);
    } else {
      if (c == '(')
        ++depthParen;
      else if (c == ')')
        --depthParen;
      else if (c == '<')
        ++depthAngle;
      else if (c == '>')
        --depthAngle;
      else if (c == '{')
        ++depthBrace;
      else if (c == '}')
        --depthBrace;
      else if (c == '[')
        ++depthBracket;
      else if (c == ']')
        --depthBracket;

      if (c == ',' && depthParen == 0 && depthAngle == 0 && depthBrace == 0 && depthBracket == 0) {
        out.push_back(',');
        skipping = false;
      }
    }
  }
  out.push_back(')');
  out.append(sig.substr(close + 1).str());
  return out;
}

static std::pair<size_t, size_t> findMethodNameRange(llvm::StringRef sig) {
  size_t paren = sig.find('(');
  if (paren == std::string::npos || paren == 0)
    return {std::string::npos, std::string::npos};
  size_t end = paren;
  while (end > 0 && std::isspace(static_cast<unsigned char>(sig[end - 1])))
    --end;
  size_t start = end;
  while (start > 0) {
    char c = sig[start - 1];
    if (std::isalnum(static_cast<unsigned char>(c)) || c == '_' || c == ':' || c == '~')
      --start;
    else
      break;
  }
  if (start == end)
    return {std::string::npos, std::string::npos};
  return {start, end};
}

static std::string methodKindForName(llvm::StringRef shortName) {
  if (shortName.starts_with("eval_comb_"))
    return "comb";
  if (shortName == "eval" || shortName == "eval_comb_pass" || shortName.starts_with("eval_"))
    return "eval";
  if (shortName.starts_with("tick"))
    return "tick";
  return "core";
}

static std::optional<SplitMethodDef> convertMethodChunk(llvm::StringRef chunk, llvm::StringRef structName,
                                                         std::string &error) {
  size_t open = chunk.find('{');
  if (open == std::string::npos) {
    error = "missing '{' in method chunk";
    return std::nullopt;
  }
  size_t close = findMatchingBraceSimple(chunk, open);
  if (close == std::string::npos) {
    error = "missing matching '}' in method chunk";
    return std::nullopt;
  }

  std::string signature = normalizeWhitespace(chunk.substr(0, open));
  std::string body = chunk.substr(open, close - open + 1).str();
  if (signature.empty()) {
    error = "empty method signature";
    return std::nullopt;
  }

  std::string declSig = signature;
  if (startsWithWord(declSig, "inline"))
    declSig = trimCopy(llvm::StringRef(declSig).drop_front(strlen("inline")));
  declSig = dropCtorInitializerForDecl(declSig);
  declSig = trimCopy(declSig);

  std::string defSig = signature;
  if (startsWithWord(defSig, "inline"))
    defSig = trimCopy(llvm::StringRef(defSig).drop_front(strlen("inline")));
  if (startsWithWord(defSig, "static"))
    defSig = trimCopy(llvm::StringRef(defSig).drop_front(strlen("static")));
  defSig = removeDefaultArgs(defSig);
  defSig = trimCopy(defSig);

  auto [nameStart, nameEnd] = findMethodNameRange(defSig);
  if (nameStart == std::string::npos || nameEnd == std::string::npos || nameEnd <= nameStart) {
    error = "failed to locate method name in signature: " + defSig;
    return std::nullopt;
  }
  std::string fullName = trimCopy(llvm::StringRef(defSig).substr(nameStart, nameEnd - nameStart));
  if (fullName.empty()) {
    error = "empty method name";
    return std::nullopt;
  }
  std::string shortName = fullName;
  if (size_t p = shortName.rfind("::"); p != std::string::npos)
    shortName = shortName.substr(p + 2);

  std::string qualifiedSig;
  qualifiedSig.reserve(defSig.size() + structName.size() + 2);
  qualifiedSig.append(defSig.substr(0, nameStart));
  if (fullName.find("::") == std::string::npos) {
    qualifiedSig.append(structName.str());
    qualifiedSig.append("::");
    qualifiedSig.append(fullName);
  } else {
    qualifiedSig.append(fullName);
  }
  qualifiedSig.append(defSig.substr(nameEnd));

  SplitMethodDef out;
  out.name = shortName;
  out.declaration = "  " + declSig + ";\n";
  out.definition = qualifiedSig + " " + body + "\n";
  out.kind = methodKindForName(shortName);
  out.bytes = out.definition.size();
  out.lines = countLines(out.definition);
  return out;
}

static bool isMethodStartLine(llvm::StringRef line, llvm::StringRef structName) {
  std::string t = trimCopy(line);
  if (t.empty())
    return false;
  if (startsWithWord(t, "struct") || startsWithWord(t, "class") || startsWithWord(t, "enum"))
    return false;
  if (t.find('(') == std::string::npos)
    return false;
  if (t.size() >= 2 && t[0] == '/' && t[1] == '/')
    return false;
  if (!(startsWithWord(t, "inline") || startsWithWord(t, "void") || startsWithWord(t, "static") ||
        startsWithWord(t, "bool") || startsWithWord(t, structName) || startsWithWord(t, "~" + structName.str()))) {
    return false;
  }
  size_t semi = t.find(';');
  size_t brace = t.find('{');
  if (semi != std::string::npos && (brace == std::string::npos || semi < brace))
    return false;
  return true;
}

static std::optional<SplitModuleResult> splitEmittedModule(llvm::StringRef emitted, llvm::StringRef structName,
                                                            std::string &error) {
  size_t structPos = emitted.find("struct " + structName.str());
  if (structPos == std::string::npos) {
    error = "cannot locate struct `" + structName.str() + "` in emitted text";
    return std::nullopt;
  }
  size_t open = emitted.find('{', structPos);
  if (open == std::string::npos) {
    error = "cannot locate struct open brace";
    return std::nullopt;
  }
  size_t close = findMatchingBraceSimple(emitted, open);
  if (close == std::string::npos) {
    error = "cannot locate struct close brace";
    return std::nullopt;
  }

  llvm::StringRef body = emitted.substr(open + 1, close - open - 1);
  SplitModuleResult out;
  out.headerBody.reserve(body.size() / 2);
  out.headerBody.append("struct ");
  out.headerBody.append(structName.str());
  out.headerBody.append(" {\n");

  size_t cursor = 0;
  while (cursor < body.size()) {
    size_t lineEnd = body.find('\n', cursor);
    size_t next = (lineEnd == std::string::npos) ? body.size() : (lineEnd + 1);
    llvm::StringRef line = body.slice(cursor, next);

    if (isMethodStartLine(line, structName)) {
      size_t methodStart = cursor;
      size_t methodOpen = body.find('{', methodStart);
      if (methodOpen == std::string::npos) {
        error = "method start without body brace";
        return std::nullopt;
      }
      if (lineEnd != std::string::npos && methodOpen > lineEnd) {
        size_t search = next;
        while (methodOpen == std::string::npos && search < body.size()) {
          size_t le = body.find('\n', search);
          size_t nx = (le == std::string::npos) ? body.size() : (le + 1);
          methodOpen = body.find('{', search);
          if (methodOpen != std::string::npos && (le == std::string::npos || methodOpen <= le))
            break;
          search = nx;
        }
      }
      if (methodOpen == std::string::npos) {
        error = "method signature without opening brace";
        return std::nullopt;
      }
      size_t methodClose = findMatchingBraceSimple(body, methodOpen);
      if (methodClose == std::string::npos) {
        error = "unterminated method body";
        return std::nullopt;
      }
      llvm::StringRef chunk = body.slice(methodStart, methodClose + 1);
      auto converted = convertMethodChunk(chunk, structName, error);
      if (!converted)
        return std::nullopt;
      out.headerBody.append(converted->declaration);
      out.headerBody.push_back('\n');
      out.methods.push_back(std::move(*converted));

      cursor = methodClose + 1;
      while (cursor < body.size() && (body[cursor] == '\r' || body[cursor] == '\n'))
        ++cursor;
      continue;
    }

    out.headerBody.append(line.str());
    cursor = next;
  }

  out.headerBody.append("};\n");
  return out;
}

static LogicalResult writeCppCompileManifest(llvm::StringRef path,
                                             llvm::StringRef targetName,
                                             llvm::ArrayRef<CppManifestSource> sources,
                                             llvm::ArrayRef<std::string> includeDirs,
                                             llvm::ArrayRef<std::string> compileDefines,
                                             llvm::StringRef topHeader) {
  llvm::json::Object manifest;
  manifest["version"] = 1;
  manifest["target_name"] = targetName.str();
  manifest["cxx_standard"] = "c++17";

  llvm::json::Array includeDirsJson;
  for (const auto &p : includeDirs)
    includeDirsJson.push_back(p);
  manifest["include_dirs"] = std::move(includeDirsJson);

  llvm::json::Array definesJson;
  for (const auto &d : compileDefines)
    definesJson.push_back(d);
  manifest["compile_defines"] = std::move(definesJson);

  llvm::json::Array srcJson;
  std::vector<std::string> hashParts;
  hashParts.reserve(sources.size() + 2);
  hashParts.push_back(targetName.str());
  hashParts.push_back(topHeader.str());
  for (const auto &s : sources) {
    llvm::json::Object obj;
    obj["path"] = s.path;
    obj["module"] = s.module;
    obj["shard"] = s.shard;
    obj["kind"] = s.kind;
    srcJson.push_back(std::move(obj));
    hashParts.push_back(s.path + "|" + s.module + "|" + s.shard + "|" + s.kind);
  }
  manifest["sources"] = std::move(srcJson);
  manifest["top_header"] = topHeader.str();

  auto hc = llvm::hash_combine_range(hashParts.begin(), hashParts.end());
  manifest["deterministic_hash"] = llvm::utohexstr(static_cast<uint64_t>(hc));

  std::string buf;
  llvm::raw_string_ostream ss(buf);
  llvm::json::OStream j(ss, 2);
  llvm::json::Value v(std::move(manifest));
  j.value(v);
  ss << "\n";
  ss.flush();
  return writeFile(path, buf);
}

struct CompileStatsSummary {
  int64_t regCount = 0;
  int64_t regBits = 0;
  int64_t memCount = 0;
  int64_t memBits = 0;
  int64_t maxLogicDepth = 0;
  int64_t wns = 0;
  int64_t tns = 0;
  int64_t logicDepthLimit = 32;
  bool fuseCombEnabled = false;
};

static int64_t getI64Attr(Operation *op, llvm::StringRef name, int64_t fallback = 0) {
  if (auto attr = op->getAttrOfType<IntegerAttr>(name))
    return static_cast<int64_t>(attr.getInt());
  return fallback;
}

static int64_t satAdd(int64_t a, int64_t b) {
  __int128 v = static_cast<__int128>(a) + static_cast<__int128>(b);
  if (v > std::numeric_limits<int64_t>::max())
    return std::numeric_limits<int64_t>::max();
  if (v < std::numeric_limits<int64_t>::min())
    return std::numeric_limits<int64_t>::min();
  return static_cast<int64_t>(v);
}

static CompileStatsSummary collectCompileStats(ModuleOp module, int64_t depthLimit) {
  CompileStatsSummary s;
  s.logicDepthLimit = depthLimit;
  bool sawWns = false;
  s.wns = depthLimit;

  for (auto f : module.getOps<func::FuncOp>()) {
    s.regCount = satAdd(s.regCount, getI64Attr(f, "pyc.stats.reg_count", 0));
    s.regBits = satAdd(s.regBits, getI64Attr(f, "pyc.stats.reg_bits", 0));
    s.memCount = satAdd(s.memCount, getI64Attr(f, "pyc.stats.mem_count", 0));
    s.memBits = satAdd(s.memBits, getI64Attr(f, "pyc.stats.mem_bits", 0));

    s.maxLogicDepth = std::max(s.maxLogicDepth, getI64Attr(f, "pyc.logic_depth.max", 0));

    int64_t fWns = getI64Attr(f, "pyc.logic_depth.wns", depthLimit);
    if (!sawWns) {
      s.wns = fWns;
      sawWns = true;
    } else {
      s.wns = std::min(s.wns, fWns);
    }
    s.tns = satAdd(s.tns, getI64Attr(f, "pyc.logic_depth.tns", 0));
  }

  if (!sawWns)
    s.wns = depthLimit;
  return s;
}

static void printCompileStats(const CompileStatsSummary &s) {
  llvm::errs() << "stats: regs=" << s.regCount << " (" << s.regBits << " bits)"
               << ", mems=" << s.memCount << " (" << s.memBits << " bits)"
               << ", max_depth=" << s.maxLogicDepth << "/" << s.logicDepthLimit
               << ", WNS=" << s.wns << ", TNS=" << s.tns
               << ", fuse_comb=" << (s.fuseCombEnabled ? "on" : "off") << "\n";
}

static LogicalResult writeCompileStatsJson(llvm::StringRef outPath, const CompileStatsSummary &s) {
  llvm::json::Object obj;
  obj["reg_count"] = s.regCount;
  obj["reg_bits"] = s.regBits;
  obj["mem_count"] = s.memCount;
  obj["mem_bits"] = s.memBits;
  obj["logic_depth_limit"] = s.logicDepthLimit;
  obj["max_logic_depth"] = s.maxLogicDepth;
  obj["wns"] = s.wns;
  obj["tns"] = s.tns;
  obj["fuse_comb_enabled"] = s.fuseCombEnabled;

  std::string buf;
  llvm::raw_string_ostream ss(buf);
  llvm::json::OStream j(ss, 2);
  llvm::json::Value v(std::move(obj));
  j.value(v);
  ss << "\n";
  ss.flush();
  return writeFile(outPath, buf);
}

int main(int argc, char **argv) {
  llvm::InitLLVM y(argc, argv);
  llvm::cl::ParseCommandLineOptions(argc, argv, "pyc-compile\n");

  DialectRegistry registry;
  registry.insert<pyc::PYCDialect, mlir::arith::ArithDialect, mlir::func::FuncDialect, mlir::scf::SCFDialect>();
  mlir::func::registerInlinerExtension(registry);

  MLIRContext ctx(registry);
  ctx.loadAllAvailableDialects();

  llvm::SourceMgr sm;
  auto fileOrErr = llvm::MemoryBuffer::getFileOrSTDIN(inputFilename);
  if (!fileOrErr) {
    llvm::errs() << "error: cannot read " << inputFilename << "\n";
    return 1;
  }
  sm.AddNewSourceBuffer(std::move(*fileOrErr), llvm::SMLoc());

  OwningOpRef<ModuleOp> module = parseSourceFile<ModuleOp>(sm, &ctx);
  if (!module) {
    llvm::errs() << "error: failed to parse MLIR\n";
    return 1;
  }

  bool cppOnly = false;
  if (simMode == "default") {
    cppOnly = false;
  } else if (simMode == "cpp-only") {
    cppOnly = true;
  } else {
    llvm::errs() << "error: unknown --sim-mode: " << simMode << " (expected: default|cpp-only)\n";
    return 1;
  }

  // Cleanup + optimization pipeline tuned for netlist-style emission.
  PassManager pm(&ctx);
  pm.addPass(createInlinerPass());
  pm.addPass(createCanonicalizerPass());
  pm.addPass(createCSEPass());
  pm.addPass(createSCCPPass());
  pm.addPass(createRemoveDeadValuesPass());
  pm.addPass(createSymbolDCEPass());

  pm.addNestedPass<func::FuncOp>(pyc::createLowerSCFToPYCStaticPass());
  pm.addNestedPass<func::FuncOp>(pyc::createEliminateWiresPass());
  pm.addNestedPass<func::FuncOp>(pyc::createEliminateDeadStatePass());
  pm.addNestedPass<func::FuncOp>(pyc::createCombCanonicalizePass());
  pm.addNestedPass<func::FuncOp>(pyc::createSLPPackWiresPass());
  pm.addNestedPass<func::FuncOp>(pyc::createCheckCombCyclesPass());
  pm.addNestedPass<func::FuncOp>(pyc::createPackI1RegsPass());
  const bool enableFuseComb = (!cppOnly) || !cppOnlyPreserveOps;
  if (enableFuseComb)
    pm.addNestedPass<func::FuncOp>(pyc::createFuseCombPass());
  pm.addPass(createCanonicalizerPass());
  pm.addPass(createCSEPass());
  pm.addPass(createRemoveDeadValuesPass());
  pm.addPass(createSymbolDCEPass());
  pm.addNestedPass<func::FuncOp>(pyc::createCheckFlatTypesPass());
  pm.addNestedPass<func::FuncOp>(pyc::createCheckNoDynamicPass());
  pm.addNestedPass<func::FuncOp>(pyc::createCheckLogicDepthPass(logicDepthLimit));
  pm.addNestedPass<func::FuncOp>(pyc::createCollectCompileStatsPass());
  if (failed(pm.run(*module))) {
    llvm::errs() << "error: pass pipeline failed\n";
    return 1;
  }

  CompileStatsSummary compileStats = collectCompileStats(*module, static_cast<int64_t>(logicDepthLimit));
  compileStats.fuseCombEnabled = enableFuseComb;
  printCompileStats(compileStats);

  auto writeSingleOutputStats = [&]() -> LogicalResult {
    if (outputFilename == "-")
      return success();
    llvm::SmallString<256> statsPath(outputFilename);
    statsPath += ".stats.json";
    return writeCompileStatsJson(statsPath, compileStats);
  };

  if (!outDir.empty()) {
    std::error_code ec = llvm::sys::fs::create_directories(outDir);
    if (ec) {
      llvm::errs() << "error: cannot create --out-dir " << outDir << ": " << ec.message() << "\n";
      return 1;
    }

    std::string top = topSymbol(*module);
    if (top.empty()) {
      llvm::errs() << "error: cannot determine top symbol (missing pyc.top and no func.func)\n";
      return 1;
    }

    if (emitKind == "verilog") {
      if (cppOnly) {
        llvm::errs() << "error: --emit=verilog is not allowed with --sim-mode=cpp-only\n";
        return 1;
      }
      llvm::json::Array verilogFiles;
      bool targetFpga = (targetKind == "fpga");
      if (!targetFpga && targetKind != "default") {
        llvm::errs() << "error: unknown --target: " << targetKind << " (expected: default|fpga)\n";
        return 1;
      }
      if (includePrims) {
        auto primDir = findPrimitivesDir(argv[0]);
        if (!primDir) {
          llvm::errs() << "error: cannot locate runtime/verilog for primitives; set PYC_PRIMITIVES_DIR\n";
          return 1;
        }
        llvm::SmallString<256> primOut(outDir);
        llvm::sys::path::append(primOut, "pyc_primitives.v");
        if (failed(emitPrimitivesFile(primOut, *primDir, targetFpga)))
          return 1;
        verilogFiles.push_back("pyc_primitives.v");
      }

      pyc::VerilogEmitterOptions opts;
      opts.includePrimitives = false; // out-dir mode uses pyc_primitives.v (or expects external primitives)
      opts.targetFpga = targetFpga;

      for (auto f : module->getOps<func::FuncOp>()) {
        std::string fname = (f.getSymName() + ".v").str();
        llvm::SmallString<256> path(outDir);
        llvm::sys::path::append(path, fname);

        std::error_code fe;
        llvm::raw_fd_ostream os(path, fe, llvm::sys::fs::OF_Text);
        if (fe) {
          llvm::errs() << "error: cannot open " << path << ": " << fe.message() << "\n";
          return 1;
        }
        if (failed(pyc::emitVerilogFunc(*module, f, os, opts)))
          return 1;
        verilogFiles.push_back(fname);
      }

      if (failed(updateManifest(outDir, top, std::move(verilogFiles), /*cppMods=*/std::nullopt)))
        return 1;

      // Optional Yosys stub (sanity synth).
      llvm::SmallString<256> ysPath(outDir);
      llvm::sys::path::append(ysPath, "yosys_synth.ys");
      std::string ys;
      llvm::raw_string_ostream yss(ys);
      yss << "# Generated by pyc-compile\n";
      if (includePrims)
        yss << "read_verilog -sv pyc_primitives.v\n";
      for (auto f : module->getOps<func::FuncOp>()) {
        yss << "read_verilog -sv " << f.getSymName().str() << ".v\n";
      }
      yss << "hierarchy -top " << top << "\n";
      yss << "proc; opt; memory; opt\n";
      yss << "synth -top " << top << "\n";
      yss.flush();
      if (failed(writeFile(ysPath, ys)))
        return 1;

      llvm::SmallString<256> statsPath(outDir);
      llvm::sys::path::append(statsPath, "compile_stats.json");
      if (failed(writeCompileStatsJson(statsPath, compileStats)))
        return 1;

      return 0;
    }

    if (emitKind == "cpp") {
      llvm::json::Array cppFiles;
      std::vector<CppManifestSource> cppManifestSources;

      // Collect direct dependencies per module for header includes.
      llvm::StringMap<llvm::SmallVector<std::string>> deps;
      for (auto f : module->getOps<func::FuncOp>()) {
        auto &v = deps[f.getSymName()];
        f.walk([&](pyc::InstanceOp inst) {
          auto calleeAttr = inst->getAttrOfType<FlatSymbolRefAttr>("callee");
          if (!calleeAttr)
            return;
          v.push_back(calleeAttr.getValue().str());
        });
        std::sort(v.begin(), v.end());
        v.erase(std::unique(v.begin(), v.end()), v.end());
      }

      bool splitModule = false;
      if (cppSplitMode == "module")
        splitModule = true;
      else if (cppSplitMode == "none")
        splitModule = false;
      else {
        llvm::errs() << "error: unknown --cpp-split mode: " << cppSplitMode << " (expected: module|none)\n";
        return 1;
      }

      auto writeHeaderPreamble = [&](llvm::raw_ostream &os, llvm::StringRef moduleName) {
        (void)moduleName;
        os << "// pyCircuit C++ emission (split)\n";
        os << "#pragma once\n";
        os << "#include <cstdlib>\n";
        os << "#include <cstdint>\n";
        os << "#include <fstream>\n";
        os << "#include <iostream>\n";
        os << "#include <string>\n";
        os << "#include <cpp/pyc_sim.hpp>\n";
      };

      auto writeSourcePreamble = [&](llvm::raw_ostream &os, llvm::StringRef headerName) {
        os << "// pyCircuit C++ emission (split)\n";
        os << "#include \"" << headerName << "\"\n\n";
        os << "namespace pyc::gen {\n\n";
      };

      auto writeSourceEpilogue = [&](llvm::raw_ostream &os) { os << "} // namespace pyc::gen\n"; };

      for (auto f : module->getOps<func::FuncOp>()) {
        std::string moduleName = f.getSymName().str();
        std::string headerName = moduleName + ".hpp";
        llvm::SmallString<256> headerPath(outDir);
        llvm::sys::path::append(headerPath, headerName);

        std::string emitted;
        {
          llvm::raw_string_ostream emitOs(emitted);
          if (failed(pyc::emitCppFunc(*module, f, emitOs)))
            return 1;
          emitOs.flush();
        }

        if (splitModule) {
          std::string splitErr;
          auto split = splitEmittedModule(emitted, moduleName, splitErr);
          if (!split) {
            llvm::errs() << "error: failed to split module `" << moduleName << "`: " << splitErr << "\n";
            return 1;
          }

          std::error_code fe;
          llvm::raw_fd_ostream hos(headerPath, fe, llvm::sys::fs::OF_Text);
          if (fe) {
            llvm::errs() << "error: cannot open " << headerPath << ": " << fe.message() << "\n";
            return 1;
          }
          writeHeaderPreamble(hos, moduleName);
          for (const std::string &dep : deps[f.getSymName()])
            hos << "#include \"" << dep << ".hpp\"\n";
          hos << "\nnamespace pyc::gen {\n\n";
          hos << split->headerBody << "\n";
          hos << "} // namespace pyc::gen\n";

          auto writeSourceFile = [&](llvm::StringRef fileName,
                                     llvm::StringRef kind,
                                     llvm::StringRef shard,
                                     llvm::ArrayRef<const SplitMethodDef *> defs) -> LogicalResult {
            if (defs.empty())
              return success();
            llvm::SmallString<256> srcPath(outDir);
            llvm::sys::path::append(srcPath, fileName);
            std::error_code se;
            llvm::raw_fd_ostream sos(srcPath, se, llvm::sys::fs::OF_Text);
            if (se) {
              llvm::errs() << "error: cannot open " << srcPath << ": " << se.message() << "\n";
              return failure();
            }
            writeSourcePreamble(sos, headerName);
            for (const SplitMethodDef *m : defs)
              sos << m->definition << "\n";
            writeSourceEpilogue(sos);

            CppManifestSource info;
            info.path = fileName.str();
            info.module = moduleName;
            info.shard = shard.str();
            info.kind = kind.str();
            cppManifestSources.push_back(std::move(info));
            return success();
          };

          std::vector<const SplitMethodDef *> allMethods;
          std::vector<const SplitMethodDef *> coreMethods;
          std::vector<const SplitMethodDef *> evalMethods;
          std::vector<const SplitMethodDef *> tickMethods;
          std::vector<const SplitMethodDef *> combMethods;
          size_t totalBytes = 0;
          size_t totalLines = 0;
          allMethods.reserve(split->methods.size());
          for (const auto &m : split->methods) {
            const SplitMethodDef *pm = &m;
            allMethods.push_back(pm);
            totalBytes += m.bytes;
            totalLines += m.lines;
            if (m.kind == "comb")
              combMethods.push_back(pm);
            else if (m.kind == "eval")
              evalMethods.push_back(pm);
            else if (m.kind == "tick")
              tickMethods.push_back(pm);
            else
              coreMethods.push_back(pm);
          }

          bool oversized =
              (totalLines > static_cast<size_t>(cppShardThresholdLines)) ||
              (totalBytes > static_cast<size_t>(cppShardThresholdBytes));

          if (!oversized) {
            if (failed(writeSourceFile(moduleName + ".cpp", "module", "000", allMethods)))
              return 1;
          } else {
            bool wroteAny = false;
            if (failed(writeSourceFile(moduleName + "__core.cpp", "core", "core", coreMethods)))
              return 1;
            if (!coreMethods.empty())
              wroteAny = true;
            auto writeMaybeShardedMethods = [&](llvm::StringRef stem,
                                                llvm::StringRef kind,
                                                llvm::ArrayRef<const SplitMethodDef *> defs,
                                                bool allowSharding) -> LogicalResult {
              if (defs.empty())
                return success();

              size_t totalBytesLocal = 0;
              size_t totalLinesLocal = 0;
              for (const SplitMethodDef *m : defs) {
                totalBytesLocal += m->bytes;
                totalLinesLocal += m->lines;
              }
              bool needsSharding =
                  allowSharding && defs.size() > 1 &&
                  ((totalBytesLocal > static_cast<size_t>(cppShardThresholdBytes)) ||
                   (totalLinesLocal > static_cast<size_t>(cppShardThresholdLines)));

              if (!needsSharding) {
                if (failed(writeSourceFile(moduleName + "__" + stem.str() + ".cpp", kind, stem, defs)))
                  return failure();
                wroteAny = true;
                return success();
              }

              size_t shardIdx = 0;
              std::vector<const SplitMethodDef *> shardDefs;
              size_t shardBytes = 0;
              size_t shardLines = 0;
              auto flushShard = [&]() -> LogicalResult {
                if (shardDefs.empty())
                  return success();
                char shardNum[8];
                std::snprintf(shardNum, sizeof(shardNum), "%03zu", shardIdx++);
                if (failed(writeSourceFile(moduleName + "__" + stem.str() + "_" + shardNum + ".cpp",
                                           kind, shardNum, shardDefs)))
                  return failure();
                wroteAny = true;
                shardDefs.clear();
                shardBytes = 0;
                shardLines = 0;
                return success();
              };

              for (const SplitMethodDef *m : defs) {
                bool limitHit =
                    !shardDefs.empty() &&
                    ((shardBytes + m->bytes > static_cast<size_t>(cppShardThresholdBytes)) ||
                     (shardLines + m->lines > static_cast<size_t>(cppShardThresholdLines)));
                if (limitHit) {
                  if (failed(flushShard()))
                    return failure();
                }
                shardDefs.push_back(m);
                shardBytes += m->bytes;
                shardLines += m->lines;
              }
              return flushShard();
            };

            // tick methods can be enormous for large top-level modules (e.g. JanusBccBackendCompat).
            // Allow sharding to avoid compiler instability/timeouts on a single huge TU.
            if (failed(writeMaybeShardedMethods("tick", "tick", tickMethods, /*allowSharding=*/true)))
              return 1;

            if (failed(writeMaybeShardedMethods("eval", "eval", evalMethods, /*allowSharding=*/true)))
              return 1;
            if (failed(writeMaybeShardedMethods("comb", "comb", combMethods, /*allowSharding=*/true)))
              return 1;

            if (!wroteAny) {
              if (failed(writeSourceFile(moduleName + "__core.cpp", "core", "core", allMethods)))
                return 1;
            }
          }
        } else {
          std::error_code fe;
          llvm::raw_fd_ostream hos(headerPath, fe, llvm::sys::fs::OF_Text);
          if (fe) {
            llvm::errs() << "error: cannot open " << headerPath << ": " << fe.message() << "\n";
            return 1;
          }
          hos << "// pyCircuit C++ emission (prototype)\n";
          hos << "#pragma once\n";
          hos << "#include <cstdlib>\n";
          hos << "#include <iostream>\n";
          hos << "#include <cpp/pyc_sim.hpp>\n";
          for (const std::string &dep : deps[f.getSymName()])
            hos << "#include \"" << dep << ".hpp\"\n";
          hos << "\nnamespace pyc::gen {\n\n";
          hos << emitted;
          hos << "\n} // namespace pyc::gen\n";
        }

        cppFiles.push_back(headerName);
      }

      if (splitModule) {
        llvm::SmallString<256> manifestPathStorage;
        if (!cppManifestPath.empty()) {
          manifestPathStorage = cppManifestPath;
        } else {
          manifestPathStorage = outDir;
          llvm::sys::path::append(manifestPathStorage, "cpp_compile_manifest.json");
        }
        std::vector<std::string> includeDirs = {std::string(outDir)};
        std::vector<std::string> compileDefines;
        std::string topHeaderName = top + ".hpp";
        if (failed(writeCppCompileManifest(manifestPathStorage, top, cppManifestSources,
                                           includeDirs, compileDefines, topHeaderName)))
          return 1;
      }

      if (failed(updateManifest(outDir, top, /*verilogMods=*/std::nullopt, std::move(cppFiles))))
        return 1;

      llvm::SmallString<256> statsPath(outDir);
      llvm::sys::path::append(statsPath, "compile_stats.json");
      if (failed(writeCompileStatsJson(statsPath, compileStats)))
        return 1;

      return 0;
    }

    llvm::errs() << "error: unknown --emit kind: " << emitKind << "\n";
    return 1;
  }

  std::error_code ec;
  llvm::raw_fd_ostream os(outputFilename, ec, llvm::sys::fs::OF_Text);
  if (ec) {
    llvm::errs() << "error: cannot open " << outputFilename << ": " << ec.message() << "\n";
    return 1;
  }

  if (emitKind == "verilog") {
    if (cppOnly) {
      llvm::errs() << "error: --emit=verilog is not allowed with --sim-mode=cpp-only\n";
      return 1;
    }
    pyc::VerilogEmitterOptions opts;
    opts.includePrimitives = includePrims;
    if (targetKind == "fpga")
      opts.targetFpga = true;
    else if (targetKind != "default") {
      llvm::errs() << "error: unknown --target: " << targetKind << " (expected: default|fpga)\n";
      return 1;
    }
    if (failed(pyc::emitVerilog(*module, os, opts)))
      return 1;
    if (failed(writeSingleOutputStats()))
      return 1;
    return 0;
  }
  if (emitKind == "cpp") {
    if (failed(pyc::emitCpp(*module, os)))
      return 1;
    if (failed(writeSingleOutputStats()))
      return 1;
    return 0;
  }

  llvm::errs() << "error: unknown --emit kind: " << emitKind << "\n";
  return 1;
}
