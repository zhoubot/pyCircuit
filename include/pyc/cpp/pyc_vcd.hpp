#pragma once

#include <cstdint>
#include <fstream>
#include <ostream>
#include <string>
#include <utility>
#include <vector>

#include "pyc_bits.hpp"

namespace pyc::cpp {

class VcdWriter {
public:
  VcdWriter() = default;

  bool open(const std::string &path, const std::string &top = "tb", const std::string &timescale = "1ns") {
    out_.open(path, std::ios::out | std::ios::trunc);
    if (!out_.is_open())
      return false;

    out_ << "$date\n  (generated by pyCircuit)\n$end\n";
    out_ << "$version\n  pyCircuit C++ TB\n$end\n";
    out_ << "$timescale " << timescale << " $end\n";
    out_ << "$scope module " << sanitizeName(top) << " $end\n";
    finalized_ = false;
    cur_time_ = ~std::uint64_t{0};
    sigs_.clear();
    return true;
  }

  bool isOpen() const { return out_.is_open(); }

  template <unsigned W>
  bool add(Wire<W> &w, const std::string &name) {
    if (!out_.is_open() || finalized_)
      return false;
    SignalDef d;
    d.width = W;
    d.name = sanitizeName(name);
    d.id = makeId(sigs_.size());
    d.ptr = &w;
    d.read = [](const void *p) -> std::uint64_t { return static_cast<const Wire<W> *>(p)->value(); };
    d.has_last = false;
    d.last = 0;
    out_ << "$var wire " << d.width << " " << d.id << " " << d.name << " $end\n";
    sigs_.push_back(std::move(d));
    return true;
  }

  void dump(std::uint64_t time) {
    if (!out_.is_open())
      return;
    if (!finalized_) {
      out_ << "$upscope $end\n";
      out_ << "$enddefinitions $end\n";
      // Initial values at time 0.
      out_ << "#0\n";
      for (auto &s : sigs_) {
        std::uint64_t v = s.read(s.ptr);
        emitValue(out_, s.width, v, s.id);
        s.last = v;
        s.has_last = true;
      }
      finalized_ = true;
      cur_time_ = 0;
    }

    if (time != cur_time_) {
      out_ << "#" << time << "\n";
      cur_time_ = time;
    }

    for (auto &s : sigs_) {
      std::uint64_t v = s.read(s.ptr);
      if (!s.has_last || v != s.last) {
        emitValue(out_, s.width, v, s.id);
        s.last = v;
        s.has_last = true;
      }
    }
  }

private:
  struct SignalDef {
    unsigned width = 1;
    std::string name{};
    std::string id{};
    const void *ptr = nullptr;
    std::uint64_t (*read)(const void *) = nullptr;
    bool has_last = false;
    std::uint64_t last = 0;
  };

  static std::string sanitizeName(const std::string &s) {
    std::string out = s;
    for (char &c : out) {
      if (c == ' ' || c == '\t' || c == '\n' || c == '\r')
        c = '_';
    }
    if (out.empty())
      out = "sig";
    return out;
  }

  static std::string makeId(std::size_t idx) {
    // Printable non-space ASCII is generally accepted in VCD identifiers.
    static constexpr char kAlphabet[] =
        "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
    static constexpr std::size_t kBase = sizeof(kAlphabet) - 1;
    std::string out;
    do {
      out.push_back(kAlphabet[idx % kBase]);
      idx /= kBase;
    } while (idx != 0);
    return out;
  }

  static void emitValue(std::ostream &os, unsigned width, std::uint64_t value, const std::string &id) {
    if (width <= 1) {
      os << ((value & 1u) ? '1' : '0') << id << "\n";
      return;
    }
    os << 'b';
    for (int b = static_cast<int>(width) - 1; b >= 0; --b) {
      os << (((value >> static_cast<unsigned>(b)) & 1u) ? '1' : '0');
    }
    os << ' ' << id << "\n";
  }

  std::ofstream out_{};
  std::vector<SignalDef> sigs_{};
  bool finalized_ = false;
  std::uint64_t cur_time_ = ~std::uint64_t{0};
};

} // namespace pyc::cpp

