#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")/.." && pwd)"
# shellcheck source=../scripts/lib.sh
source "${ROOT_DIR}/scripts/lib.sh"
pyc_find_pyc_compile

OUT_ROOT="${ROOT_DIR}/examples/generated"
mkdir -p "${OUT_ROOT}"

emit_one() {
  local name="$1"
  local src="$2"
  shift 2
  local emit_args=("$@")
  local outdir="${OUT_ROOT}/${name}"

  mkdir -p "${outdir}"
  pyc_log "emit ${name}: ${src}"

  # Emit MLIR to a temp file (keep repo-clean: only check in .v/.hpp outputs).
  local tmp_pyc
  tmp_pyc="$(mktemp -t "pycircuit.${name}.pyc")"

  local emit_cmd=(python3 -m pycircuit.cli emit "${src}")
  if (( ${#emit_args[@]} )); then
    emit_cmd+=("${emit_args[@]}")
  fi
  emit_cmd+=(-o "${tmp_pyc}")

  PYTHONDONTWRITEBYTECODE=1 PYTHONPATH="$(pyc_pythonpath):${ROOT_DIR}" "${emit_cmd[@]}"
  "${PYC_COMPILE}" "${tmp_pyc}" --emit=verilog -o "${outdir}/${name}.v"
  "${PYC_COMPILE}" "${tmp_pyc}" --emit=cpp -o "${outdir}/${name}.hpp"
}

# Python examples.
emit_one counter "${ROOT_DIR}/examples/counter.py"
emit_one fifo_loopback "${ROOT_DIR}/examples/fifo_loopback.py"
emit_one issue_queue_2picker "${ROOT_DIR}/examples/issue_queue_2picker.py"
emit_one multiclock_regs "${ROOT_DIR}/examples/multiclock_regs.py"
emit_one wire_ops "${ROOT_DIR}/examples/wire_ops.py"
emit_one jit_control_flow "${ROOT_DIR}/examples/jit_control_flow.py"
emit_one jit_pipeline_vec "${ROOT_DIR}/examples/jit_pipeline_vec.py"
emit_one jit_cache "${ROOT_DIR}/examples/jit_cache.py"

# FastFwd: allow overriding FE count at JIT time.
# Example:
#   FASTFWD_N_FE=8 bash examples/update_generated.sh
FASTFWD_EMIT_ARGS=()
if [[ -n "${FASTFWD_N_FE:-}" ]]; then
  FASTFWD_EMIT_ARGS+=(--param "N_FE=${FASTFWD_N_FE}")
fi
if (( ${#FASTFWD_EMIT_ARGS[@]} )); then
  emit_one fastfwd_pyc "${ROOT_DIR}/examples/fastfwd_pyc/fastfwd_pyc.py" "${FASTFWD_EMIT_ARGS[@]}"
else
  emit_one fastfwd_pyc "${ROOT_DIR}/examples/fastfwd_pyc/fastfwd_pyc.py"
fi

# LinxISA CPU (pyCircuit).
emit_one linx_cpu_pyc "${ROOT_DIR}/examples/linx_cpu_pyc/linx_cpu_pyc.py"
mv -f "${OUT_ROOT}/linx_cpu_pyc/linx_cpu_pyc.hpp" "${OUT_ROOT}/linx_cpu_pyc/linx_cpu_pyc_gen.hpp"

# FastFwd (pyCircuit).
mv -f "${OUT_ROOT}/fastfwd_pyc/fastfwd_pyc.hpp" "${OUT_ROOT}/fastfwd_pyc/fastfwd_pyc_gen.hpp"

emit_fastfwd_exam_top() {
  local outdir="$1"
  local nfe="$2"
  local outfile="${outdir}/exam2021_top.v"

  pyc_log "emit fastfwd_pyc: exam2021_top.v (N_FE=${nfe})"

  cat >"${outfile}" <<EOF
// Generated by pyCircuit examples/update_generated.sh
// Top wrapper: EXAM2021_TOP
//
// This wrapper hides FEIN/FEOUT ports by instantiating Forwarding Engines (FE)
// internally and exposing only the exam-style PKTIN/PKTOUT/BKPR interface.
//
// Files required to simulate/synthesize this example:
// - ${outdir##*/}/fastfwd_pyc.v          (FastFwd core netlist)
// - ${outdir##*/}/fe.v                  (FE model stub; replace with official exam FE RTL)
// - include/pyc/verilog/*.v             (pyCircuit Verilog primitives, used via Verilog include directives in fastfwd_pyc.v)
//
module EXAM2021_TOP(
  input clk,
  input rst_n,
  input lane0_pkt_in_vld,
  input lane1_pkt_in_vld,
  input lane2_pkt_in_vld,
  input lane3_pkt_in_vld,
  input [127:0] lane0_pkt_in_data,
  input [127:0] lane1_pkt_in_data,
  input [127:0] lane2_pkt_in_data,
  input [127:0] lane3_pkt_in_data,
  input [4:0] lane0_pkt_in_ctrl,
  input [4:0] lane1_pkt_in_ctrl,
  input [4:0] lane2_pkt_in_ctrl,
  input [4:0] lane3_pkt_in_ctrl,
  output lane0_pkt_out_vld,
  output lane1_pkt_out_vld,
  output lane2_pkt_out_vld,
  output lane3_pkt_out_vld,
  output [127:0] lane0_pkt_out_data,
  output [127:0] lane1_pkt_out_data,
  output [127:0] lane2_pkt_out_data,
  output [127:0] lane3_pkt_out_data,
  output reg pkt_in_bkpr
);
  localparam integer N_FE = ${nfe};

  wire rst;
  assign rst = ~rst_n;

  // Internal FE buses.
  wire [N_FE-1:0]       fwd_pkt_data_vld;
  wire [N_FE*128-1:0]   fwd_pkt_data;
  wire [N_FE*2-1:0]     fwd_pkt_lat;
  wire [N_FE-1:0]       fwd_pkt_dp_vld;
  wire [N_FE*128-1:0]   fwd_pkt_dp_data;
  wire [N_FE-1:0]       fwded_pkt_data_vld;
  wire [N_FE*128-1:0]   fwded_pkt_data;

  wire pkt_in_bkpr_w;

  // FastFwd core (generated from pyCircuit).
  FastFwd U_CORE (
    .clk(clk),
    .rst(rst),
    .lane0_pkt_in_vld(lane0_pkt_in_vld),
    .lane1_pkt_in_vld(lane1_pkt_in_vld),
    .lane2_pkt_in_vld(lane2_pkt_in_vld),
    .lane3_pkt_in_vld(lane3_pkt_in_vld),
    .lane0_pkt_in_data(lane0_pkt_in_data),
    .lane1_pkt_in_data(lane1_pkt_in_data),
    .lane2_pkt_in_data(lane2_pkt_in_data),
    .lane3_pkt_in_data(lane3_pkt_in_data),
    .lane0_pkt_in_ctrl(lane0_pkt_in_ctrl),
    .lane1_pkt_in_ctrl(lane1_pkt_in_ctrl),
    .lane2_pkt_in_ctrl(lane2_pkt_in_ctrl),
    .lane3_pkt_in_ctrl(lane3_pkt_in_ctrl),
EOF

  local last_e=$((nfe - 1))

  for ((e = 0; e < nfe; e++)); do
    cat >>"${outfile}" <<EOF
    .fwded${e}_pkt_data_vld(fwded_pkt_data_vld[${e}]),
    .fwded${e}_pkt_data(fwded_pkt_data[${e}*128+127:${e}*128]),
EOF
  done

  cat >>"${outfile}" <<EOF
    .pkt_in_bkpr(pkt_in_bkpr_w),
    .lane0_pkt_out_vld(lane0_pkt_out_vld),
    .lane0_pkt_out_data(lane0_pkt_out_data),
    .lane1_pkt_out_vld(lane1_pkt_out_vld),
    .lane1_pkt_out_data(lane1_pkt_out_data),
    .lane2_pkt_out_vld(lane2_pkt_out_vld),
    .lane2_pkt_out_data(lane2_pkt_out_data),
    .lane3_pkt_out_vld(lane3_pkt_out_vld),
    .lane3_pkt_out_data(lane3_pkt_out_data),
EOF

  for ((e = 0; e < nfe; e++)); do
    local tail=","
    if (( e == last_e )); then
      tail=""
    fi
    cat >>"${outfile}" <<EOF
    .fwd${e}_pkt_data_vld(fwd_pkt_data_vld[${e}]),
    .fwd${e}_pkt_data(fwd_pkt_data[${e}*128+127:${e}*128]),
    .fwd${e}_pkt_lat(fwd_pkt_lat[${e}*2+1:${e}*2]),
    .fwd${e}_pkt_dp_vld(fwd_pkt_dp_vld[${e}]),
    .fwd${e}_pkt_dp_data(fwd_pkt_dp_data[${e}*128+127:${e}*128])${tail}
EOF
  done

  cat >>"${outfile}" <<EOF
  );

  // Keep the exam-style BKPR port type (output reg).
  always @(*) begin
    pkt_in_bkpr = pkt_in_bkpr_w;
  end

  // Instantiate Forwarding Engines internally.
  genvar i;
  generate
    for (i = 0; i < N_FE; i = i + 1) begin: FE
      FE U_FE (
        .clk(clk),
        .rst_n(rst_n),
        .fwd_pkt_data_vld(fwd_pkt_data_vld[i]),
        .fwd_pkt_data(fwd_pkt_data[i*128+127:i*128]),
        .fwd_pkt_lat(fwd_pkt_lat[i*2+1:i*2]),
        .fwd_pkt_dp_vld(fwd_pkt_dp_vld[i]),
        .fwd_pkt_dp_data(fwd_pkt_dp_data[i*128+127:i*128]),
        .fwded_pkt_data_vld(fwded_pkt_data_vld[i]),
        .fwded_pkt_data(fwded_pkt_data[i*128+127:i*128])
      );
    end
  endgenerate
endmodule
EOF
}

fastfwd_detect_nfe() {
  local vfile="$1"
  python3 - "${vfile}" <<'PY'
import re
import sys
from pathlib import Path

v = Path(sys.argv[1]).read_text(encoding="utf-8", errors="ignore")
idx = [int(m.group(1)) for m in re.finditer(r"\bfwded(\d+)_pkt_data_vld\b", v)]
if not idx:
    print("0")
    sys.exit(0)
print(str(max(idx) + 1))
PY
}

# FastFwd exam-style top wrapper + FE stub.
FASTFWD_OUTDIR="${OUT_ROOT}/fastfwd_pyc"
FASTFWD_N_FE="$(fastfwd_detect_nfe "${FASTFWD_OUTDIR}/fastfwd_pyc.v")"
if [[ "${FASTFWD_N_FE}" == "0" ]]; then
  pyc_log "warn: cannot detect FE count for fastfwd_pyc; skipping exam wrapper"
else
  cp -f "${ROOT_DIR}/examples/fastfwd_pyc/fe.v" "${FASTFWD_OUTDIR}/fe.v"
  emit_fastfwd_exam_top "${FASTFWD_OUTDIR}" "${FASTFWD_N_FE}"
fi

pyc_log "ok: wrote outputs under ${OUT_ROOT}"
